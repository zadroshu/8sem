# -*- coding: utf-8 -*-
"""kalah.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mx-NLafhGWrOxPv3XHTZXKRNVq2PfPUu

[Решение игры Kalah с использованием обучения с подкреплением — часть 1](https://torlenor.org/machine%20learning/reinforcement%20learning/2020/10/23/machine_learning_reinforment_learning_kalah_part1.html)

MaxScoreRepeat
"""

import random


class Kalah:
    def __init__(self, num_holes=6, num_seeds=6.):
        self.num_holes = num_holes
        self.num_seeds = num_seeds
        self.board = [num_seeds for _ in range(num_holes * 2 + 2)]  # Заполняем лунки

        self.kalah1_index = int(self.num_holes)  # Индекс корзины первого игрока
        self.kalah2_index = int(self.num_holes) + 1  # Индекс корзины второго игрока

        self.board[self.kalah1_index] = 0.
        self.board[self.kalah2_index] = 0.

        self.current_player = 0  # Текущий игрок

        self.diff1 = self.num_holes + 2  # Разница между противоположными лунками относительно прямого порядка
        self.diff2 = self.num_holes  # Разница между противоположными лунками относительно обратного порядка

        self.move = 0

    def play(self, hole):
        if self.current_player == 1: hole -= self.num_holes
        seeds = self.board[hole]  # Запоминаем количество в выбранной лунке
        self.board[hole] = 0.  # Обнуляем выбранную лунку

        # Запускаем распределение камней
        while seeds > 0:
            hole = hole + 1 if hole >= 0 else hole - 1

            # Если прошли свою корзину, переходим на другую сторону
            if hole == self.num_holes + 1:
                hole = -1
            if hole == -1 * self.num_holes - 2:
                hole = 0

            # Если распределение дошло до корзины соперника, пропускаем её
            if hole == self.num_holes and self.current_player == 1:
                continue
            if hole == -1 * self.num_holes - 1 and self.current_player == 0:
                continue

            self.board[hole] += 1.  # Увеличиваем кол-во камней в лунке
            seeds -= 1  # Уменьшаем кол-во камней в выбранной лунке

        # Если последний камень оказался в корзине, выходим без смены хода
        if hole == self.num_holes:
            return
        if hole == -1 * self.num_holes - 1:
            return

        # Если последний камень попал в пустую лунку принадлежащую ему и противоположная лунка соперника не пуста, то этот камень и все камни из противоположной лунки соперника игрок переносит себе в корзину
        if self.board[hole] == 1 and self.board[
            hole + self.diff1 if self.current_player == 0 else hole + self.diff2] > 0:
            if hole >= 0 and self.current_player == 0 or hole < 0 and self.current_player == 1:
                self.board[self.num_holes if hole >= 0 else self.num_holes + 1] += self.board[
                                                                                       hole + self.diff1 if hole >= 0 else hole + self.diff2] + 1
                self.board[hole] = 0.
                self.board[hole + self.diff1 if self.current_player == 0 else hole + self.diff2] = 0.

        self.current_player = 1 - self.current_player
        return

    def game_over(self):
        return sum(self.board[:self.num_holes]) == 0 or sum(self.board[self.diff1:]) == 0 or self.board[
            -1 * self.num_holes - 1] > (self.num_holes * self.num_holes) or self.board[self.num_holes] > (
                           self.num_holes * self.num_holes)

    def get_winner(self):
        if not self.game_over():
            return None
        return 0 if self.board[self.num_holes] > self.board[-1 * self.num_holes - 1] else 1

    def start_game(self):
        while not self.game_over():
            print("=========== Move ", self.move, "===========")
            print("player 2:", self.board[-1 * self.num_holes - 1], self.board[self.num_holes + 2:])
            print("player 1:  ", self.board[:self.num_holes], self.board[self.num_holes])
            hole = int(input("Player {}'s turn. Enter hole number(0-5): ".format(self.current_player + 1)))
            while True:
                if hole >= 0 and hole <= 5: break
                hole = int(input("Player {}'s turn. Enter hole number(0-5): ".format(self.current_player + 1)))
            self.next_move(hole)
        print("Game over. Player {} wins!".format(self.get_winner() + 1))

    def next_move(self, hole):
        self.play(hole)
        self.move += 1


game = Kalah()
